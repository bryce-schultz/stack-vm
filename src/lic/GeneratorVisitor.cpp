//***********************************************
// GeneratorVisitor.cpp
//***********************************************

#include "GeneratorVisitor.h"
#include "Nodes.h"
#include "Error.h"

GeneratorVisitor::GeneratorVisitor(const std::string &output_filename):
    outputFilename(output_filename)
{
}

void GeneratorVisitor::visitAllChildren(Node *node)
{
    // Visit the root node.
    node->visit(this);

    // Don't attepmt to output to the file if there is an error.
    if (global::hadError)
    {
        return;
    }

    std::ofstream file(outputFilename);

    if (file.is_open())
    {
        file << outputBuffer.str();
        file.close();

        printf("-> %s\n", outputFilename.c_str());
    }
}

void GeneratorVisitor::visit(ProgramNode *node)
{
    out("# generated by li compiler (lic)\n\n");

    bool hasMain = node->hasMain();

    out("# global variable declarations\n");

    // Visit the variable declarations in the program.
    for (int i = 0; i < node->getStatements()->getStatementCount(); i++)
    {
        auto statement = node->getStatements()->getStatement(i);
        // If the statement is a function declaration, we need to output the function label.
        // This is done so that we can jump to the function later.
        if (statement->isDecl() && !statement->isFuncDecl())
        {
            statement->visit(this);
        }
    }

    out("\n# jump to the starting point\n");
    if (hasMain)
        out("jmp func_main\n");
    else
        out("jmp main\n");

    out("\n# function declarations\n");
    // Visit the function declarations in the program.
    for (int i = 0; i < node->getStatements()->getStatementCount(); i++)
    {
        auto statement = node->getStatements()->getStatement(i);
        // If the statement is a function declaration, we need to output the function label.
        // This is done so that we can jump to the function later.
        if (statement->isFuncDecl())
        {
            statement->visit(this);
        }
    }

    out("\n# main entry point\n");
    // If the program does not have a main function, we need to output the main function label.
    if (!node->hasMain())
    {
        out("main:\n");
    }

    // Visit the statements in the program.
    for (int i = 0; i < node->getStatements()->getStatementCount(); i++)
    {
        auto statement = node->getStatements()->getStatement(i);
        // If the statement is not a function declaration, we need to output the function label.
        // This is done so that we can jump to the function later.
        if (!statement->isDecl())
        {
            statement->visit(this);
        }
    }

    // Tell the vm the program is done.
    out("halt\n");
}

void GeneratorVisitor::visit(BinaryExpressionNode *node)
{
    bool leftIsString = node->getLeft()->isString();
    bool rightIsString = node->getRight()->isString();
    bool resultIsString = leftIsString || rightIsString;

    // Visit the left side of the binary expression.
    node->getLeft()->visit(this);
    // If the result will be a string, we need to convert the left operand to a string if it is not already a string.
    if (resultIsString && !leftIsString)
    {
        out("tostr\n");
    }

    // Visit the right side of the binary expression.
    node->getRight()->visit(this);
    // If the result will be a string, we need to convert the right operand to a string if it is not already a string.
    if (resultIsString && !rightIsString)
    {
        out("tostr\n");
    }

    if (resultIsString && (node->getOperator()->getValue() != '+'))
    {
        error("string concatenation is only supported with '+' operator", node->getOperator()->getToken());
        return;
    }

    // Get the operator of the binary expression and 
    // output the corresponding instruction.
    switch (node->getOperator()->getValue())
    {
    case '+':
        {
            if (resultIsString)
            {
                out("concat");
            }
            else
            {
                out("add");
            }
            break;
        }
    case '-':
        out("sub");
        break;
    case '*':
        out("mul");
        break;
    case '/':
        out("div");
        break;
    case '%':
        out("mod");
        break;
    case '^':
        out("pow");
        break;
    case '<':
        out("lt");
        break;
    case '>':
        out("gt");
        break;
    case EQUAL:
        out("eq");
        break;
    case NOT_EQUAL:
        out("ne");
        break;
    case LESS_OR_EQUAL:
        out("le");
        break;
    case GREATER_OR_EQUAL:
        out("ge");
        break;
    case OR:
        out("or");
        break;
    case AND:
        out("and");
        break;
    }
    out("\n");
}

void GeneratorVisitor::visit(NumberExpressionNode *node)
{
    // Push the value of the integer expression onto the stack.
    out("push");
    out(node->getValue());
    out("\n");
}

void GeneratorVisitor::visit(PrintStatementNode *node)
{
    auto expression = node->getExpression();

    // Ensure the expression is not null.
    if (!expression)
    {
        return;
    }

    // Visit the expression.
    expression->visit(this);

    // Output the print instruction based on expression type.
    if (expression->isString())
    {
        out("printstr");
    }
    else
    {
        out("print");
    }

    out("\n");
}

void GeneratorVisitor::visit(UnaryExpressionNode *node)
{
    bool isString = node->getExpr()->isString();

    if (isString && node->getOperator()->getValue() != INCREMENT && node->getOperator()->getValue() != DECREMENT)
    {
        error("strings only support '++' and '--' unary operators.", node->getOperator()->getToken());
        return;
    }

    // Visit the expression of the unary expression.
    node->getExpr()->visit(this);

    // Get the operator of the unary expression and output the corresponding instruction.
    switch (node->getOperator()->getValue())
    {
        case '!':
        {
            out("fact");
            break;
        }
        case '-':
        {
            out("neg");
            break;
        }
        case INCREMENT:
        {
            if (isString)
            {
                out("caps");
            }
            else
            {
                out("inc");
            }
            break;
        }
        case DECREMENT:
        {
            if (isString)
            {
                out("lower");
            }
            else
            {
                out("dec");
            }
            break;
        }
    }
    out("\n");

    // If our expression was a variable, we store the result back into the variable.
    if (node->getExpr()->isVariable())
    {
        auto var = dynamic_cast<VariableExpressionNode *>(node->getExpr());
        out("store");
        out(variables[var->getSymbol()]);
        out("\n");
    }
}

void GeneratorVisitor::visit(AsmStatementNode *node)
{
    // Get the raw assembly code and output it.
    std::string asm_ = static_cast<StringExpressionNode*>(node->getExpression())->getValue();
    out(asm_);
    out("\n");
}

void GeneratorVisitor::visit(StringExpressionNode *node)
{
    // Get the string value of the string expression.
    std::string str = node->getValue();

    // Loop backwards through the string, pushing each character onto the stack.
    for (int i = str.size() - 1; i >= 0; i--)
    {
        out("push");
        out(str[i]);
        out("\n");
    }

    // Push the size of the string onto the stack.
    out("push");
    out(str.size());
    out("\n");
}

void GeneratorVisitor::visit(ConcatNode *node)
{
    // Visit the left and right children of the concat node.
    node->getLeft()->visit(this);
    node->getRight()->visit(this);

    // Output the concat instruction.
    out("concat\n");
}

void GeneratorVisitor::visit(FuncDeclNode *node)
{
    auto name = node->getSymbol()->getName();
    auto paramList = node->getParamList();

    std::string paramListStr = "(";
    if (paramList)
    {
        for (int i = 0; i < paramList->getParamCount(); i++)
        {
            auto param = paramList->getParam(i);
            auto param_name = param->getSymbol()->getName();
            paramListStr += param_name + (i == paramList->getParamCount() - 1 ? "" : ", ");
        }
    }
    paramListStr += ")";

    out("# fn " + name + paramListStr + "\n");
    // Create function label format is "func_<function_name>:".
    out("func_" + name + ":\n");

    // Get the parameter list and visit it.
    if (paramList)
    {
        paramList->visit(this);
    }

    // Visit the function body.
    auto body = node->getBody();
    if (body)
    {
        body->visit(this);
    }
    else
    {
        error("function " + name + " is declared, but has no body", node->getToken());
    }

    if (name != "main")
    {
        out("ret\n");
    }
}

void GeneratorVisitor::visit(CallNode *node)
{
    // Get the function name and arguments.
    auto name = node->getSymbol()->getName();
    auto args = node->getArgs();

    // Visit the arguments.
    if (args)
    {
        args->visit(this);
    }

    // Call the function.
    out("call func_" + name + "\n");
}

void GeneratorVisitor::visit(ParamListNode *node)
{
    // visit the parameters in the parameter list backwards
    for (int i = node->getParamCount() - 1; i >= 0; i--)
    {
        auto param = node->getParam(i);
        param->visit(this);
    }
}

void GeneratorVisitor::visit(ParamNode *node)
{
    // Get the symbol of the parameter.
    auto symbol = node->getSymbol();

    // Store the parameter in the variables map if it doesn't already exist.
    if (variables.find(symbol) == variables.end())
    {
        variables[symbol] = variables.size();
    }

    // Store the stack value in the parameter, skipping the return address.
    out("pstore");
    out(variables[symbol]);
    out("\n");
}

std::string GeneratorVisitor::getOutput() const
{
    return outputBuffer.str();
}

void GeneratorVisitor::out(const std::string &text)
{
    outputBuffer << text;
}

void GeneratorVisitor::out(int64_t value)
{
    outputBuffer << " " << value;
}

void GeneratorVisitor::visit(VarDeclNode *node)
{
    // Get the symbol and expression of the variable declaration.
    auto symbol = node->getSymbol();
    auto expr = node->getExpression();

    out("# var " + symbol->getName() + "\n");

    // Ensure the expression is numeric as string variables are not supported yet.
    if (expr->isNumeric())
    {
        // Store the variable in the variables map if it doesn't already exist.
        // We use the symbol as the key so that variables in different scopes can have the same name.
        if (variables.find(symbol) == variables.end())
        {
            variables[symbol] = variables.size();
        }

        // Visit the expression and store the result in the variable.
        expr->visit(this);

        out("store");
        out(variables[symbol]);
        out("\n");
    }
}

void GeneratorVisitor::visit(VariableExpressionNode *node)
{
    // Get the symbol and name of the variable expression.
    auto symbol = node->getSymbol();
    auto token = node->getToken();

    // Ensure the variable is defined.
    if (variables.find(symbol) == variables.end())
    {
        undefined(token);
    }

    // Load the variable onto the stack.
    out("load");
    out(variables[symbol]);
    out("\n");
}

void GeneratorVisitor::visit(AssignNode *node)
{
    // Get the symbol and expression of the assignment.
    auto symbol = node->getSymbol();
    auto expr = node->getExpression();

    if (expr->isNumeric())
    {
        // Store the variable in the variables map if it doesn't already exist.
        if (variables.find(symbol) == variables.end())
        {
            undefined(symbol->getToken());
            return;
        }

        // Visit the expression and store the result in the variable.
        expr->visit(this);

        out("store");
        out(variables[symbol]);
        out("\n");
    }
}

void GeneratorVisitor::visit(ForStatementNode *node)
{   
    // This is a static variable so this is only set once.
    static int forCount = 1;
    // Create a unique id for the for loop.
    int forId = forCount++;
    
    // Create a starting label for the for loop and visit the init expression.
    out("for" + std::to_string(forId) + "start:\n");
    node->getInit()->visit(this);

    // Create a label for the loop and visit the condition.
    // We always want to jump back to before the condition check.
    out("for" + std::to_string(forId) + "loop:\n");
    node->getCondition()->visit(this);

    // If the condition evaluates to 0 (false), jump to the end of the for loop.
    out("jz for" + std::to_string(forId) + "end\n");

    // Visit the statement and increment expression.
    node->getStatement()->visit(this);
    node->getIncrement()->visit(this);

    // Jump back to the start of the for loop.
    out("jmp for" + std::to_string(forId) + "loop\n");

    // Create a label for the end of the for loop.
    out("for" + std::to_string(forId) + "end:\n");
}

void GeneratorVisitor::visit(WhileStatementNode *node)
{
    // This is a static variable so this is only set once.
    static int whileCount = 1;
    // Create a unique id for the while loop.
    int whileId = whileCount++;

    // Create a label for the start of the while loop and visit the condition.
    out("while" + std::to_string(whileId) + "loop:\n");
    node->getCondition()->visit(this);

    // If the condition evaluates to 0 (false), jump to the end of the while loop.
    out("jz while" + std::to_string(whileId) + "end\n");

    // Visit the body of the while loop if it exists.
    if (node->getBody())
    {
        node->getBody()->visit(this);
    }

    // Jump back to the start of the while loop.
    out("jmp while" + std::to_string(whileId) + "loop\n");

    // Create a label for the end of the while loop.
    out("while" + std::to_string(whileId) + "end:\n");
}

void GeneratorVisitor::visit(IfStatementNode *node)
{
    // This is a static variable so this is only set once.
    static int ifCount = 1;
    // Create a unique id for the if statement.
    int ifId = ifCount++;

    // Visit the condition of the if statement.
    node->getCondition()->visit(this);

    // If the if statement has an else statement, jump to the else statement if the condition is false.
    // Otherwise, jump to the end of the if statement.
    StatementNode *elseStatement = node->getElseStatement();
    if (elseStatement)
    {
        out("jz if" + std::to_string(ifId) + "else\n");
    }
    else
    {
        out("jz if" + std::to_string(ifId) + "end\n");
    }

    // Visit the body of the if statement.
    node->getStatement()->visit(this);

    // Jump to the end of the if statement.
    out("jmp if" + std::to_string(ifId) + "end\n");
    
    // If the if statement has an else statement, visit the else statement.
    if (elseStatement)
    {
        // Create a label for the else statement and visit it.
        out("if" + std::to_string(ifId) + "else:\n");
        elseStatement->visit(this);
    }

    // Create a label for the end of the if statement.
    out("if" + std::to_string(ifId) + "end:\n");
}

void GeneratorVisitor::visit(ReturnStatementNode *node)
{
    // Get the expression of the return statement.
    auto expr = node->getExpression();

    // If the expression is not null, visit it.
    if (expr)
    {
        expr->visit(this);
        out("retval\n");
    }
    else
    {
        out("ret\n");
    }
}

void GeneratorVisitor::visit(StringConversionNode *node)
{
    // Visit the expression of the string conversion.
    node->getExpression()->visit(this);

    // Output the string conversion instruction.
    out("tostr\n");
}